// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: albums.sql

package db

import (
	"context"
	"database/sql"
)

const addMediaToAlbum = `-- name: AddMediaToAlbum :exec
INSERT INTO album_media (album_id, media_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddMediaToAlbumParams struct {
	AlbumID int32 `json:"album_id"`
	MediaID int32 `json:"media_id"`
}

func (q *Queries) AddMediaToAlbum(ctx context.Context, arg AddMediaToAlbumParams) error {
	_, err := q.db.ExecContext(ctx, addMediaToAlbum, arg.AlbumID, arg.MediaID)
	return err
}

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO album (
    title, description, user_id, is_public, is_shared
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, title, description, user_id, is_public, is_shared, created_at, updated_at, deleted_at
`

type CreateAlbumParams struct {
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	UserID      int32          `json:"user_id"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsShared    sql.NullBool   `json:"is_shared"`
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, createAlbum,
		arg.Title,
		arg.Description,
		arg.UserID,
		arg.IsPublic,
		arg.IsShared,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.IsPublic,
		&i.IsShared,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT id, title, description, user_id, is_public, is_shared, created_at, updated_at, deleted_at FROM album
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetAlbumByID(ctx context.Context, id int32) (Album, error) {
	row := q.db.QueryRowContext(ctx, getAlbumByID, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.IsPublic,
		&i.IsShared,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAlbumMedia = `-- name: GetAlbumMedia :many
SELECT m.id, m.filename, m.stored_name, m.url, m.type, m.mime_type, m.size, m.user_id, m.created_at, m.updated_at, m.deleted_at FROM media m
JOIN album_media am ON am.media_id = m.id
WHERE am.album_id = $1 AND m.deleted_at IS NULL
`

func (q *Queries) GetAlbumMedia(ctx context.Context, albumID int32) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumMedia, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.StoredName,
			&i.Url,
			&i.Type,
			&i.MimeType,
			&i.Size,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllAlbums = `-- name: ListAllAlbums :many
SELECT a.id, a.title, a.description, a.user_id, a.is_public, a.is_shared, a.created_at, a.updated_at, a.deleted_at, u.name as user_name
FROM album a
JOIN users u ON a.user_id = u.id
WHERE a.deleted_at IS NULL
ORDER BY a.created_at DESC
`

type ListAllAlbumsRow struct {
	ID          int32          `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	UserID      int32          `json:"user_id"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsShared    sql.NullBool   `json:"is_shared"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
	DeletedAt   sql.NullTime   `json:"deleted_at"`
	UserName    string         `json:"user_name"`
}

func (q *Queries) ListAllAlbums(ctx context.Context) ([]ListAllAlbumsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllAlbumsRow
	for rows.Next() {
		var i ListAllAlbumsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.IsPublic,
			&i.IsShared,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAlbums = `-- name: ListUserAlbums :many
SELECT a.id, a.title, a.description, a.user_id, a.is_public, a.is_shared, a.created_at, a.updated_at, a.deleted_at, u.name as user_name
FROM album a
JOIN users u ON a.user_id = u.id
WHERE a.user_id = $1 AND a.deleted_at IS NULL
ORDER BY a.created_at DESC
`

type ListUserAlbumsRow struct {
	ID          int32          `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	UserID      int32          `json:"user_id"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsShared    sql.NullBool   `json:"is_shared"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
	DeletedAt   sql.NullTime   `json:"deleted_at"`
	UserName    string         `json:"user_name"`
}

func (q *Queries) ListUserAlbums(ctx context.Context, userID int32) ([]ListUserAlbumsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserAlbums, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserAlbumsRow
	for rows.Next() {
		var i ListUserAlbumsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.IsPublic,
			&i.IsShared,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMediaFromAlbum = `-- name: RemoveMediaFromAlbum :exec
DELETE FROM album_media
WHERE album_id = $1 AND media_id = $2
`

type RemoveMediaFromAlbumParams struct {
	AlbumID int32 `json:"album_id"`
	MediaID int32 `json:"media_id"`
}

func (q *Queries) RemoveMediaFromAlbum(ctx context.Context, arg RemoveMediaFromAlbumParams) error {
	_, err := q.db.ExecContext(ctx, removeMediaFromAlbum, arg.AlbumID, arg.MediaID)
	return err
}

const softDeleteAlbum = `-- name: SoftDeleteAlbum :exec
UPDATE album
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteAlbum(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, softDeleteAlbum, id)
	return err
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE album
SET 
    title = $2,
    description = $3,
    is_public = $4,
    is_shared = $5,
    updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)
WHERE id = $1
RETURNING id, title, description, user_id, is_public, is_shared, created_at, updated_at, deleted_at
`

type UpdateAlbumParams struct {
	ID          int32          `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsShared    sql.NullBool   `json:"is_shared"`
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbum,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.IsPublic,
		arg.IsShared,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.IsPublic,
		&i.IsShared,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
