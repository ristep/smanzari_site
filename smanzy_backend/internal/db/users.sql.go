// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
)

const assignRole = `-- name: AssignRole :exec
INSERT INTO user_roles (user_id, role_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssignRoleParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) AssignRole(ctx context.Context, arg AssignRoleParams) error {
	_, err := q.db.ExecContext(ctx, assignRole, arg.UserID, arg.RoleID)
	return err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name)
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateRole(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password, name, tel, age, address, city, country, gender
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Email    string         `json:"email"`
	Password string         `json:"password"`
	Name     string         `json:"name"`
	Tel      sql.NullString `json:"tel"`
	Age      sql.NullInt32  `json:"age"`
	Address  sql.NullString `json:"address"`
	City     sql.NullString `json:"city"`
	Country  sql.NullString `json:"country"`
	Gender   sql.NullString `json:"gender"`
}

type CreateUserRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.Name,
		arg.Tel,
		arg.Age,
		arg.Address,
		arg.City,
		arg.Country,
		arg.Gender,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Tel,
		&i.Age,
		&i.Address,
		&i.City,
		&i.Country,
		&i.Gender,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, created_at, updated_at FROM roles
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
FROM users
WHERE email = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserByEmailRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Tel,
		&i.Age,
		&i.Address,
		&i.City,
		&i.Country,
		&i.Gender,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmailWithDeleted = `-- name: GetUserByEmailWithDeleted :one
SELECT 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
FROM users
WHERE email = $1
LIMIT 1
`

type GetUserByEmailWithDeletedRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) GetUserByEmailWithDeleted(ctx context.Context, email string) (GetUserByEmailWithDeletedRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithDeleted, email)
	var i GetUserByEmailWithDeletedRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Tel,
		&i.Age,
		&i.Address,
		&i.City,
		&i.Country,
		&i.Gender,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserByIDRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Tel,
		&i.Age,
		&i.Address,
		&i.City,
		&i.Country,
		&i.Gender,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int32) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
FROM users
WHERE deleted_at IS NULL
ORDER BY id
`

type ListUsersRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Name,
			&i.Tel,
			&i.Age,
			&i.Address,
			&i.City,
			&i.Country,
			&i.Gender,
			&i.EmailVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRole = `-- name: RemoveRole :exec
DELETE FROM user_roles
WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) RemoveRole(ctx context.Context, arg RemoveRoleParams) error {
	_, err := q.db.ExecContext(ctx, removeRole, arg.UserID, arg.RoleID)
	return err
}

const restoreUser = `-- name: RestoreUser :exec
UPDATE users
SET deleted_at = NULL
WHERE id = $1
`

func (q *Queries) RestoreUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, restoreUser, id)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, id)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = $2,
    tel = $3,
    age = $4,
    address = $5,
    city = $6,
    country = $7,
    gender = $8,
    updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)
WHERE id = $1
RETURNING 
    id, email, password, name, 
    COALESCE(tel, '') as tel, 
    COALESCE(age, 0) as age, 
    COALESCE(address, '') as address, 
    COALESCE(city, '') as city, 
    COALESCE(country, '') as country, 
    COALESCE(gender, '') as gender, 
    COALESCE(email_verified, false) as email_verified,
    created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Tel     sql.NullString `json:"tel"`
	Age     sql.NullInt32  `json:"age"`
	Address sql.NullString `json:"address"`
	City    sql.NullString `json:"city"`
	Country sql.NullString `json:"country"`
	Gender  sql.NullString `json:"gender"`
}

type UpdateUserRow struct {
	ID            int32        `json:"id"`
	Email         string       `json:"email"`
	Password      string       `json:"password"`
	Name          string       `json:"name"`
	Tel           string       `json:"tel"`
	Age           int32        `json:"age"`
	Address       string       `json:"address"`
	City          string       `json:"city"`
	Country       string       `json:"country"`
	Gender        string       `json:"gender"`
	EmailVerified bool         `json:"email_verified"`
	CreatedAt     int64        `json:"created_at"`
	UpdatedAt     int64        `json:"updated_at"`
	DeletedAt     sql.NullTime `json:"deleted_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Tel,
		arg.Age,
		arg.Address,
		arg.City,
		arg.Country,
		arg.Gender,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Tel,
		&i.Age,
		&i.Address,
		&i.City,
		&i.Country,
		&i.Gender,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
